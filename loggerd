#!/usr/bin/env python3

import os, sys
import logging
from logging.config import fileConfig
import asyncio
import uvloop
import click
import signal
import serial
from configobj import ConfigObj
from datalogger.core import IngressTunnel, PacketCosumer
from datalogger.internet import device_connection_checker, ping_connection_checker
from datalogger.serial_transport import SerialTransport
from datalogger.storage import StorageRunner
from datalogger.pin import *
from datalogger.heartbeat import heartbeat
from datalogger.button import button_detect
from datalogger.counter import fast_counter_detect, direct_counter_detect
from datalogger.temperature import TemperatureRunner
from datalogger.rc522 import RC522Runner

asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())

@click.group()
def cli():
    pass

@cli.command()
@click.option('--file', default='config.ini', help='config file path')
def server(file):
    
    # Set up logger's config file
    fileConfig(file, disable_existing_loggers=False)
    # For normal config
    config = ConfigObj(file)
    logger = logging.getLogger(__name__)
    pidfile = config['default']['pidfile']

    def signal_handler(sig, frame):
        os.unlink(pidfile)
        exit()

    if os.path.isfile(pidfile):
        logger.info("<{} is already running, exit>".format(pidfile))
        sys.exit()

    logger.info("<DataLogger start>")
    open(pidfile, "w").write(str(os.getpid()))   
    signal.signal(signal.SIGTERM, signal_handler)
    try:
        loop = asyncio.get_event_loop()
        serial_coros = list()
        frame_queues = (asyncio.Queue(), asyncio.Queue())
        storage_queue = asyncio.Queue()

        async def create_serial_connection(loop, protocol_factory, serial_port):
            protocol = protocol_factory(frame_queues)
            transport = SerialTransport(loop, protocol, serial_port)
            return (transport, protocol)

        for key, item in config['input'].items():
            if item.get('type') == 'serial':
                ser = serial.Serial(item.get('name'), baudrate=item.get('baudrate'), \
                        timeout=float(item.get('rx_timeout')))
                coro = create_serial_connection(loop, IngressTunnel, ser)
                serial_coros.append(coro)
        loop.run_until_complete(asyncio.gather(*serial_coros))

        if config.get('internet') is not None:
            internet_timeout = int(config['internet'].get('timeout'))
            loop.create_task(ping_connection_checker(loop, storage_queue, internet_timeout))

            watch_nic_list = config['internet'].get('watch')

            if type(watch_nic_list) is str:
                watch_nic_list = [watch_nic_list]
            elif watch_nic_list is None:
                watch_nic_list = []
            else:
                pass
            tasks = [device_connection_checker(storage_queue, nic) for nic in watch_nic_list]
            loop.run_until_complete(asyncio.gather(*tasks))

        if config.get('heartbeat') is not None:
            heartbeat_timeout = int(config['heartbeat'].get('timeout'))
            loop.create_task(heartbeat(loop, storage_queue, heartbeat_timeout))
        
        if config.get('counter') is not None:
            fast_freq = config['config'].get('fast_freq') 
            if fast_freq is not None:
                loop.create_task(fast_counter_detect(loop, storage_queue, int(fast_freq))))
            direct_freq = config['config'].get('direct_freq')
            if direct_freq is not None:
                loop.create_task(direct_counter_detect(loop, storage_queue, int(direct_freq)))

        if config.get('button') is not None:
            loop.create_task(button_detect(loop, storage_queue))

        loop.create_task(PacketCosumer(loop, frame_queues, storage_queue, config).run())

        loop.create_task(StorageRunner(loop, storage_queue, config).run())

        if config.get('temperature') is not None:
            loop.create_task(TemperatureRunner(loop, storage_queue))

        if config.get('rc522') is not None:
            loop.create_task(RC522Runner(loop, stroage_queue))

        loop.run_forever()
    except Exception as e:
        logger.info("<Loop exception: {}>".format(str(e)))
    finally:
        logger.info("<DataLogger end>")
        loop.close()
        os.unlink(pidfile)

if __name__ == "__main__":
    cli()

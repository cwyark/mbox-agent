#!/usr/bin/env python3

import os, sys
import logging
from logging.config import fileConfig
import asyncio
import uvloop
import click
import signal
import serial
from configobj import ConfigObj
from datalogger.core import IngressTunnel, PacketCosumer
from datalogger.internet import device_connection_checker, ping_connection_checker
from datalogger.serial_transport import SerialTransport
from datalogger.storage import StorageRunner
from datalogger.pin import *
from datalogger.heartbeat import heartbeat
from datalogger.button import button_detect
from datalogger.counter import fast_counter_detect, direct_counter_detect

asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())

@click.group()
def cli():
    pass

@cli.command()
@click.option('--file', default='config.ini', help='config file path')
def server(file):
    
    led_on(POWER_LED)

    # Set up logger's config file
    fileConfig(file, disable_existing_loggers=False)
    # For normal config
    config = ConfigObj(file)
    logger = logging.getLogger(__name__)
    pidfile = config['default']['pidfile']

    def signal_handler(sig, frame):
        os.unlink(pidfile)
        exit()

    if os.path.isfile(pidfile):
        logger.info("<{} is already running, exit>".format(pidfile))
        sys.exit()

    logger.info("<DataLogger start>")
    open(pidfile, "w").write(str(os.getpid()))   
    signal.signal(signal.SIGTERM, signal_handler)
    try:
        loop = asyncio.get_event_loop()
        serial_coros = list()
        frame_queues = (asyncio.Queue(), asyncio.Queue())
        storage_queue = asyncio.Queue()

        async def create_serial_connection(loop, protocol_factory, serial_port):
            protocol = protocol_factory(frame_queues)
            transport = SerialTransport(loop, protocol, serial_port)
            return (transport, protocol)

        for key, item in config['input'].items():
            if item.get('type') == 'serial':
                ser = serial.Serial(item.get('name'), baudrate=item.get('baudrate'), \
                        timeout=float(item.get('rx_timeout')))
                coro = create_serial_connection(loop, IngressTunnel, ser)
                serial_coros.append(coro)
        loop.run_until_complete(asyncio.gather(*serial_coros))

        internet_timeout = int(config['internet'].get('timeout'))
        loop.create_task(ping_connection_checker(loop, storage_queue, internet_timeout))

        heartbeat_interval = int(config['default'].get('heartbeat'))
        loop.create_task(heartbeat(loop, storage_queue, heartbeat_interval))

        loop.create_task(fast_counter_detect(loop, storage_queue, 0.005))
        loop.create_task(direct_counter_detect(loop, storage_queue, 0.01))

        loop.create_task(button_detect(loop, storage_queue))
        loop.create_task(PacketCosumer(loop, frame_queues, storage_queue, config).run())
        loop.create_task(StorageRunner(loop, storage_queue, config).run())

        watch_nic_list = config['internet'].get('watch')

        if type(watch_nic_list) is str:
            watch_nic_list = [watch_nic_list]
        elif watch_nic_list is None:
            watch_nic_list = []
        else:
            pass
        tasks = [device_connection_checker(storage_queue, nic) for nic in watch_nic_list]
        loop.run_until_complete(asyncio.gather(*tasks))

        loop.run_forever()
    except Exception as e:
        logger.info("<Loop exception: {}>".format(str(e)))
    finally:
        logger.info("<DataLogger end>")
        loop.close()
        os.unlink(pidfile)

if __name__ == "__main__":
    cli()

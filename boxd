#!/usr/bin/env python3

import os, sys
import logging
import logging.handlers
import asyncio
import uvloop
import click
from boxagent.box import BoxPacketReceiver, SERIAL_RECV_TIMEOUT
from boxagent.event import internet_connection_checker
from boxagent.serial_transport import SerialTransport

asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())

# Set up the logging system
PID_FILE_PATH = "/tmp/box.pid"

logging.basicConfig(level=logging.DEBUG, 
        format="%(name)-12s %(levelname)-8s %(message)s", 
        handlers = [ logging.handlers.SysLogHandler(address = '/dev/log')
            ]
        )
@click.command()
def server():
    logger = logging.getLogger(__name__)

    if os.path.isfile(PID_FILE_PATH):
        logger.info("[EVT]<daemon> [CAUSE]<none> [MSG]<{} is already running, exit>".format(PID_FILE_PATH))
        sys.exit()

    logger.info("[EVT]<daemon> [CAUSE]<none> [MSG]<BoxAgent start>")

    open(PID_FILE_PATH, "w").write(str(os.getpid()))   

    try:
        loop = asyncio.get_event_loop()
        import serial
        ser = serial.serial_for_url("/dev/ttyS0", baudrate=115200, timeout=SERIAL_RECV_TIMEOUT)
        proto = BoxPacketReceiver()
        ser_trans = SerialTransport(loop, proto, ser)
        ser_trans, _ = loop.run_until_complete((ser_trans, proto))
        loop.run_until_complete(asyncio.gather(
            internet_connection_checker(ser_trans, 'eth0'),
            internet_connection_checker(ser_trans, 'wlan0')
            ))
        loop.run_forever()
    except Exception as e:
        logger.info("[EVT]<daemon> [CAUSE]<none> [MSG]<Loop exception: {}>".format(str(e)))
    finally:
        logger.info("[EVT]<daemon> [CUASE]<none> [MSG]<BoxAgent end>")
        loop.close()
        os.unlink(PID_FILE_PATH)

if __name__ == "__main__":
    server()

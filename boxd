#!/usr/bin/env python3

import os, sys, traceback
import logging
import logging.handlers
import asyncio
import serial_asyncio
import uvloop
from boxagent.box import BoxPacketReceiver, SERIAL_RECV_TIMEOUT
from boxagent.event import internet_connection_checker

asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())

# Set up the logging system
PID_FILE_PATH = "/tmp/box.pid"

logging.basicConfig(level=logging.DEBUG, 
        format="%(name)-12s %(levelname)-8s %(message)s", 
        handlers = [ logging.handlers.SysLogHandler(address = '/dev/log')
            ]
        )

if __name__ == "__main__":

    logger = logging.getLogger(__name__)

    if os.path.isfile(PID_FILE_PATH):
        logger.info("[EVT]<daemon> [CAUSE]<none> [MSG]<{} is already running, exit>".format(PID_FILE_PATH))
        sys.exit()

    logger.info("[EVT]<daemon> [CAUSE]<none> [MSG]<BoxAgent start>")

    open(PID_FILE_PATH, "w").write(str(os.getpid()))   

    try:
        loop = asyncio.get_event_loop()
        coro = serial_asyncio.create_serial_connection(loop, BoxPacketReceiver, "/dev/ttyS0", baudrate=115200, timeout=SERIAL_RECV_TIMEOUT)
        ser_trans, ser_proto = loop.run_until_complete(coro)
        loop.run_until_complete(asyncio.gather(
            internet_connection_checker(ser_trans, 'eth0'),
            internet_connection_checker(ser_trans, 'wlan0')
            ))
        loop.run_forever()
    except Exception as e:
        logger.info("[EVT]<daemon> [CAUSE]<none> [MSG]<Loop exception: {}>".format(str(e)))
    finally:
        logger.info("[EVT]<daemon> [CUASE]<none> [MSG]<BoxAgent end>")
        loop.close()
        os.unlink(PID_FILE_PATH)
